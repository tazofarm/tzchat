// src/lib/api.ts
// -------------------------------------------------------------
// ✅ ENV 최우선 → dev-remote 강제가드 → 런타임 분기
// + 요청 인터셉터/인스턴스 수준 핫픽스: dev-remote에서 localhost:2000 → 원격으로 강제 리라이트
// -------------------------------------------------------------
import axios, {
  type InternalAxiosRequestConfig,
  type AxiosResponse,
  type AxiosError,
} from 'axios';

const RAW_MODE = (import.meta as any)?.env?.MODE as string | undefined;
const RAW_VITE_MODE = (import.meta as any)?.env?.VITE_MODE as string | undefined;
const MODE = (RAW_VITE_MODE && RAW_VITE_MODE.trim()) || RAW_MODE || 'development';

const OVERRIDE_KEY = 'DEV_API_BASE_URL_OVERRIDE';
const TOKEN_KEY = 'TZCHAT_AUTH_TOKEN';
const AUTH_MODE = (import.meta as any)?.env?.VITE_AUTH_MODE || 'jwt';

// 원격 기본값(서버)
const REMOTE_DEFAULT_ORIGIN = 'https://tzchat.tazocode.com';

// 플래그
const FORCE_DEV_REMOTE =
  (import.meta as any)?.env?.VITE_DEV_REMOTE === 'true' ||
  (import.meta as any)?.env?.VITE_REMOTE === '1';
const IS_DEV_REMOTE = FORCE_DEV_REMOTE || MODE === 'dev-remote' || RAW_VITE_MODE === 'dev-remote';

const DISABLE_OVERRIDE =
  (import.meta as any)?.env?.VITE_DISABLE_API_OVERRIDE === 'true' ||
  MODE === 'dev-remote' || MODE === 'web' || MODE === 'production';

// -------- 유틸: /api 보장 --------
function normalize(base: string): string {
  let u = (base || '').trim();
  if (!u) return '/api';
  u = u.replace(/\/+$/g, '');
  if (!/\/api$/i.test(u)) u = `${u}/api`;
  return u;
}

// -------- baseURL 결정 --------
function resolveBaseURL(): { base: string; source: string } {
  // 1) ✅ ENV 최우선 (VITE_API_BASE_URL 또는 VITE_API_BASE)
  const ENV_BASE_URL = (import.meta as any)?.env?.VITE_API_BASE_URL as string | undefined;
  const ENV_BASE_ALT = (import.meta as any)?.env?.VITE_API_BASE as string | undefined;
  const PICKED_ENV = (ENV_BASE_URL && ENV_BASE_URL.trim())
    ? ENV_BASE_URL
    : (ENV_BASE_ALT && ENV_BASE_ALT.trim())
      ? ENV_BASE_ALT
      : undefined;
  if (PICKED_ENV) {
    const envUrl = normalize(PICKED_ENV);
    console.log('[HTTP][CFG]', { source: '.env', base: envUrl, MODE, RAW_MODE, RAW_VITE_MODE, AUTH_MODE });
    return { base: envUrl, source: '.env' };
  }

  // 2) ✅ dev-remote 강제 가드 (ENV가 비어도 무조건 원격으로)
  if (IS_DEV_REMOTE) {
    const guard = normalize(REMOTE_DEFAULT_ORIGIN);
    console.warn('[HTTP][CFG]', {
      source: 'dev-remote-forced',
      note: 'dev-remote detected → forcing remote origin',
      base: guard,
      MODE,
      RAW_MODE,
      RAW_VITE_MODE,
    });
    return { base: guard, source: 'dev-remote-forced' };
  }

  // 3) (옵션) 로컬 오버라이드 — dev(local)에서만 허용
  if (!DISABLE_OVERRIDE) {
    try {
      const ls = localStorage.getItem(OVERRIDE_KEY);
      if (ls && ls.trim()) {
        const over = normalize(ls);
        console.log('[HTTP][CFG]', { source: 'localStorage', over, MODE, RAW_MODE, RAW_VITE_MODE });
        return { base: over, source: 'localStorage' };
      }
    } catch {}
  } else {
    try {
      const has = !!localStorage.getItem(OVERRIDE_KEY);
      if (has) {
        console.warn('[HTTP][CFG]', { note: 'override-ignored', reason: 'mode', MODE, key: OVERRIDE_KEY });
      }
    } catch {}
  }

  // 4) 런타임 분기
  const { protocol, hostname, port, origin } = window.location;
  const isHttps = protocol === 'https:';
  const isDevPort = ['8081', '5173', '5174', '3000'].includes(port || '');
  const isLocalHost =
    hostname === 'localhost' ||
    hostname === '127.0.0.1' ||
    /^192\.168\./.test(hostname) ||
    /^10\./.test(hostname);
  const isCapacitor =
    protocol === 'capacitor:' ||
    (typeof origin === 'string' && origin.startsWith('capacitor://')) ||
    protocol === 'file:' ||
    protocol === 'ionic:';

  if (isCapacitor) {
    const base = normalize(`http://${hostname || 'localhost'}:2000`);
    console.warn('[HTTP][CFG] Capacitor/file → fallback :2000', { base, origin, protocol, MODE });
    return { base, source: 'capacitor-fallback' };
  }
  if (isHttps) {
    const base = normalize(origin);
    console.log('[HTTP][CFG] https-origin', { base, MODE });
    return { base, source: 'https-origin' };
  }
  if (!isHttps && (isDevPort || isLocalHost)) {
    const base = normalize(`http://${hostname || 'localhost'}:2000`);
    console.log('[HTTP][CFG] dev localhost → :2000', { base, hostname, port, MODE });
    return { base, source: 'dev-localhost' };
  }
  const fallback = normalize(origin);
  console.log('[HTTP][CFG] fallback-origin', { base: fallback, MODE });
  return { base: fallback, source: 'fallback-origin' };
}

// -------- 최종 baseURL 계산 --------
const { base: FINAL_BASE_URL, source: FINAL_SOURCE } = resolveBaseURL();
console.log('[HTTP][CFG][FINAL]', {
  baseURL: FINAL_BASE_URL,
  source: FINAL_SOURCE,
  MODE,
  RAW_MODE,
  RAW_VITE_MODE,
  AUTH_MODE,
});

// ===== JWT 토큰 관리 =====
export function getAuthToken(): string | null {
  try { return localStorage.getItem(TOKEN_KEY); } catch { return null; }
}
export function setAuthToken(token?: string | null) {
  try {
    if (token && token.trim()) {
      localStorage.setItem(TOKEN_KEY, token);
      console.log('[AUTH][SET]', { hasToken: true, len: token.length });
    } else {
      localStorage.removeItem(TOKEN_KEY);
      console.log('[AUTH][SET]', { hasToken: false });
    }
  } catch {}
}
export function clearToken() {
  try { localStorage.removeItem(TOKEN_KEY); console.log('[AUTH][CLR]', { ok: true }); } catch {}
}
export function getApiBaseURL(): string { return FINAL_BASE_URL; }
export function clearApiOverride() {
  try { localStorage.removeItem(OVERRIDE_KEY); console.log('[HTTP][CFG]', { step: 'clearApiOverride', ok: true }); } catch {}
}
export function debugApiConfig() {
  try {
    const override = localStorage.getItem(OVERRIDE_KEY);
    console.log('[HTTP][DBG]', {
      MODE, RAW_MODE, RAW_VITE_MODE, AUTH_MODE,
      FINAL_BASE_URL, FINAL_SOURCE,
      overrideExists: !!override, overrideValue: override || null,
      envBaseUrl: (import.meta as any)?.env?.VITE_API_BASE_URL || null,
      envBaseAlt: (import.meta as any)?.env?.VITE_API_BASE || null,
      forceRemote: FORCE_DEV_REMOTE, isDevRemote: IS_DEV_REMOTE,
    });
  } catch {
    console.log('[HTTP][DBG]', {
      MODE, RAW_MODE, RAW_VITE_MODE, AUTH_MODE,
      FINAL_BASE_URL, FINAL_SOURCE,
      overrideExists: 'unknown',
      envBaseUrl: (import.meta as any)?.env?.VITE_API_BASE_URL || null,
      envBaseAlt: (import.meta as any)?.env?.VITE_API_BASE || null,
      forceRemote: FORCE_DEV_REMOTE, isDevRemote: IS_DEV_REMOTE,
    });
  }
}

// -------- Axios 인스턴스 --------
export const api = axios.create({
  baseURL: FINAL_BASE_URL,
  withCredentials: true,
  timeout: 15000,
  headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
});

// ✅ 인스턴스 레벨 안전장치: dev-remote인데 기본 baseURL이 로컬이면 즉시 교체
(() => {
  const DEV_REMOTE_BASE = normalize(REMOTE_DEFAULT_ORIGIN); // https://tzchat.tazocode.com/api
  const cur = api.defaults.baseURL || '';
  if (IS_DEV_REMOTE && /^http:\/\/localhost:2000\/api/i.test(cur)) {
    console.warn('[HTTP][CFG] api.defaults.baseURL rewrite (init) →', { from: cur, to: DEV_REMOTE_BASE });
    api.defaults.baseURL = DEV_REMOTE_BASE;
  }
})();

// 요청 인터셉터
api.interceptors.request.use((cfg: InternalAxiosRequestConfig) => {
  // ✅ dev-remote 핫픽스: 가장 먼저 baseURL 교체 (로그 조립 이전)
  const DEV_REMOTE_BASE = normalize(REMOTE_DEFAULT_ORIGIN); // => https://tzchat.tazocode.com/api
  const isDevRemoteFlag =
    IS_DEV_REMOTE ||
    (import.meta as any)?.env?.MODE === 'dev-remote' ||
    (import.meta as any)?.env?.VITE_MODE === 'dev-remote' ||
    (import.meta as any)?.env?.VITE_DEV_REMOTE === 'true' ||
    (import.meta as any)?.env?.VITE_REMOTE === '1';

  if (isDevRemoteFlag) {
    // cfg.baseURL 존재 시 우선 교체
    if (cfg.baseURL && /^http:\/\/localhost:2000\/api/i.test(cfg.baseURL)) {
      console.warn('[HTTP][CFG] dev-remote rewrite(cfc) →', { from: cfg.baseURL, to: DEV_REMOTE_BASE });
      cfg.baseURL = DEV_REMOTE_BASE;
    }
    // 혹시나 defaults가 로컬이면 한 번 더 방어
    const cur = (cfg as any)?.baseURL || api.defaults.baseURL || '';
    if (/^http:\/\/localhost:2000\/api/i.test(cur)) {
      console.warn('[HTTP][CFG] dev-remote rewrite(def) →', { from: cur, to: DEV_REMOTE_BASE });
      (cfg as any).baseURL = DEV_REMOTE_BASE;
      api.defaults.baseURL = DEV_REMOTE_BASE;
    }
  }

  // 이후부터 로그 조립
  const path = cfg.url ? (cfg.url.startsWith('/') ? cfg.url : `/${cfg.url}`) : '';
  const fullUrl = `${cfg.baseURL || ''}${path}`;
  const token = getAuthToken();

  if (token && !(cfg.headers as any)?.Authorization) {
    (cfg.headers as any) = { ...(cfg.headers as any), Authorization: `Bearer ${token}` };
  }

  let safeData: any = cfg.data;
  try {
    if (path.startsWith('/login') && safeData && typeof safeData === 'object') {
      const clone = { ...(safeData as any) };
      if ('password' in clone) clone.password = '(hidden)';
      if ('pw' in clone) clone.pw = '(hidden)';
      safeData = clone;
    }
  } catch {}

  console.log('[HTTP][REQ]', {
    method: (cfg.method || 'get').toUpperCase(),
    url: fullUrl,
    params: cfg.params,
    data: safeData,
    withCredentials: cfg.withCredentials,
    hasBearer: !!token,
  });
  return cfg;
});

// 응답 인터셉터
api.interceptors.response.use(
  (res: AxiosResponse) => {
    console.log('[HTTP][RES]', {
      status: res.status,
      url: res.config?.url,
      size: typeof res.data === 'string' ? res.data.length : undefined,
    });
    return res;
  },
  (err: AxiosError) => {
    const status = err.response?.status;
    const data = err.response?.data;
    const url = err.config?.url;
    console.log('[HTTP][ERR]', {
      status,
      url,
      message: err.message,
      isAxiosError: !!(err as any).isAxiosError,
      data,
    });

    if (status === 401) {
      clearToken();
    }
    return Promise.reject(err);
  }
);

// --- 인증 API ---
export const AuthAPI = {
  async login(payload: { username: string; password: string }) {
    const res = await api.post('/login', payload);
    const token =
      (res?.data as any)?.token ??
      (res?.data as any)?.data?.token ??
      null;
    if (token) setAuthToken(token);
    return res;
  },
  me() {
    return api.get('/me');
  },
  async logout() {
    try {
      await api.post('/logout');
    } finally {
      clearToken();
    }
  },
};
